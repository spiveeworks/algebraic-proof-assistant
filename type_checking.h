#ifndef APA_TYPE_CHECKING_H
#define APA_TYPE_CHECKING_H

#include <stdio.h>

#include "buffer.h"

#include "eval.h"

/* Extended version of expr_eq that can beta reduce. Decrements/frees its intro
   buffer and arg buffer, since it is optimized for the case where most of the
   expressions it is unifying were actually generated by beta reduction. */
bool expr_unify_destructive(size_t depth, struct expr a, struct expr b) {
    /* Since when we test the intros of a and b, one of them will run out of
       intros first, and we don't need to test those intros again after that,
       our strategy will be to discard the entire list of intros ONCE it has
       been tested, avoiding any unnecessary concatenations when it comes time
       to beta reduce a or b, since whichever one we reduce will be the one
       that already had all of its intro rules match.

       This means that once the number tested equals the number of intros a or
       b has, that one should drop its intros, and if it owned its intro list
       uniquely, then we can actually call expr_unify_destructive directly on
       its intro types, and simply free the intro list without worrying about
       any reference counts. */
    size_t a_intros_tested = 0;
    size_t b_intros_tested = 0;

    bool intros_match = false;
    while (true) {
        if (a.lambda_intro_count > b.lambda_intro_count) {
            /* a has a lambda intro that we need to unify with something other
               than a lambda intro in b. If b has even a single pi intro, then
               it doesn't match. */
            if (b.pi_intro_count != 0) break;
        } else if (b.lambda_intro_count > a.lambda_intro_count) {
            if (a.pi_intro_count != 0) break;
        }
        /* Otherwise the number of lambda intros match, so whether there is a
           pi or not we can just try to match as many intros as we can, and
           then try some beta reduction, or eventually even try to unify the
           heads and arg buffers themselves. */

        size_t a_intro_count = a.lambda_intro_count + a.pi_intro_count;
        size_t b_intro_count = b.lambda_intro_count + b.pi_intro_count;

        /* TODO: we could just skip common lambdas, and only unify pi? */
        struct parameter_spec *a_specs =
            (struct parameter_spec*)&a.lambda_intro_types[1];
        struct parameter_spec *b_specs =
            (struct parameter_spec*)&b.lambda_intro_types[1];
        while (a_intros_tested < a_intro_count
            && b_intros_tested < b_intro_count)
        {
            struct parameter_spec *a_spec = &a_specs[a_intros_tested];
            struct parameter_spec *b_spec = &b_specs[b_intros_tested];
            struct expr a_child = a_spec->type;
            if (a.lambda_intro_types->reference_count > 1) {
                /* We don't own the intro list, so increment a_child's
                   reference counts before we use it, since recursing consumes
                   the copy it is passed. */
                copy_expr(NULL, &a_child);
            }
            struct expr b_child = b_spec->type;
            if (b.lambda_intro_types->reference_count > 1) {
                /* Like a_child, we need to increase any reference counts in
                   b_child. */
                copy_expr(NULL, &b_child);
            }
            bool children_match = expr_unify_destructive(depth, a_child, b_child);
            /* Mark them as tested before we break, so that we don't double
               free them. */
            depth += 1;
            a_intros_tested += 1;
            b_intros_tested += 1;
            if (!children_match) break;
        }
        if (a_intro_count > 0 && a_intros_tested == a_intro_count) {
            /* We have tested all of the intros in a, so hide them, lest we
               concat to a list of intros we are never going to read again. */
            if (a.lambda_intro_types->reference_count > 1) {
                a.lambda_intro_types->reference_count -= 1;
            } else {
                /* If we own the intros uniquely, then we test its types
                   destructively, and since we tested all of its types, it is
                   now uninitialized, so we can simply free it. */
                free(a.lambda_intro_types);
            }
            a.lambda_intro_count = 0;
            a.pi_intro_count = 0;
            a.lambda_intro_types = NULL;
            a_intro_count = 0;
            a_intros_tested = 0;
        }
        if (b_intro_count > 0 && b_intros_tested == b_intro_count) {
            /* Similar for b. */
            if (b.lambda_intro_types->reference_count > 1) {
                b.lambda_intro_types->reference_count -= 1;
            } else {
                /* If we own the intros uniquely, then we test its types
                   destructively, and since we tested all of its types, it is
                   now uninitialized, so we can simply free it. */
                free(b.lambda_intro_types);
            }
            b.lambda_intro_count = 0;
            b.pi_intro_count = 0;
            b.lambda_intro_types = NULL;
            b_intro_count = 0;
            b_intros_tested = 0;
        }

        if (a_intro_count == 0) {
            /* Before we can continue unifying, we need to simplify a, to see
               what its head term is when head-normalised. */
            bool reduced = reduce_expr_once(depth, &a);
            if (reduced) continue;
        }
        if (b_intro_count == 0) {
            bool reduced = reduce_expr_once(depth, &b);
            if (reduced) continue;
        }
        /* Either a or b has a head term that isn't a lambda or a pi intro, so
           we can stop unifying lambda and pi intros now. If both have head
           terms that aren't lambdo or pi, then unifying intros succeeded, and
           we can try unifying other stuff, otherwise we just clean up and
           leave. */
        intros_match = a_intro_count == 0 && b_intro_count == 0;
        break;
    }

    if (!intros_match) {
        /* We need to return false, but first we need to clean up. */
        if (a_intros_tested > 0 && a.lambda_intro_types->reference_count == 1) {
            /* we have destroyed some of the intro types in a, so we should
               finish destroying them and free and hide the list itself. */
            size_t a_intro_count = a.lambda_intro_count + a.pi_intro_count;
            struct parameter_spec *a_specs =
                (struct parameter_spec*)&a.lambda_intro_types[1];
            for (int i = a_intros_tested; i < a_intro_count; i++) {
                destroy_expr(&a_specs[a_intros_tested].type);
            }
            free(a.lambda_intro_types);
            /* Hide it so it doesn't double-free. */
            a.lambda_intro_count = 0;
            a.pi_intro_count = 0;
            a.lambda_intro_types = NULL;
        }
        /* Because we hid the intro lists after cleaning them up, we can just
           defer to the normal destroy algorithm for the other cases. */
        destroy_expr(&a);

        if (b_intros_tested > 0 && b.lambda_intro_types->reference_count == 1) {
            /* we have destroyed some of the intro types in b, so we should
               finish destroying them and free and hide the list itself. */
            size_t b_intro_count = b.lambda_intro_count + b.pi_intro_count;
            struct parameter_spec *b_specs =
                (struct parameter_spec*)&b.lambda_intro_types[1];
            for (int i = b_intros_tested; i < b_intro_count; i++) {
                destroy_expr(&b_specs[b_intros_tested].type);
            }
            free(b.lambda_intro_types);
            /* Hide it so it doesn't double-free. */
            b.lambda_intro_count = 0;
            b.pi_intro_count = 0;
            b.lambda_intro_types = NULL;
        }
        destroy_expr(&b);

        /* All cleaned up, now we can return false. */
        return false;
    }

    /* else the intros matched, time to unify the head and args. */
    bool heads_match = true;
    if (a.head_type != b.head_type) heads_match = false;

    if (a.head_type == EXPR_VAR || a.head_type == EXPR_GLOBAL) {
        if (a.head_var_index != b.head_var_index) heads_match = false;
    }
    /* else arity 0, heads are automatically equal. */

    if (!heads_match || a.arg_count != b.arg_count) {
        destroy_expr(&a);
        destroy_expr(&b);
        return false;
    }

    struct expr *a_args = (struct expr*)&a.arg_buffer[1];
    struct expr *b_args = (struct expr*)&b.arg_buffer[1];
    size_t args_tested = 0;
    bool args_match = true;
    while (args_tested < a.arg_count) {
        struct expr a_child = a_args[args_tested];
        if (a.arg_buffer->reference_count > 1) {
            /* We don't own the intro list, so increment a_child's
               reference counts before we use it, since recursing consumes
               the copy it is passed. */
            copy_expr(NULL, &a_child);
        }
        struct expr b_child = b_args[args_tested];
        if (b.arg_buffer->reference_count > 1) {
            /* Like a_child, we need to increase any reference counts in
               b_child. */
            copy_expr(NULL, &b_child);
        }
        bool children_match = expr_unify_destructive(depth, a_child, b_child);
        /* Mark them as tested before we break, so that we don't double
           free them. */
        args_tested += 1;
        if (!children_match) {
            args_match = true;
            break;
        }
    }

    if (args_tested > 0) {
        if (a.arg_buffer->reference_count > 1) {
            /* We know there are no intros, so just decrement this counter and
               consider a destroyed. */
            a.arg_buffer->reference_count -= 1;
        } else {
            /* We have destroyed some, so destroy the rest and free. */
            for (int i = args_tested; i < a.arg_count; i++) {
                destroy_expr(&a_args[i]);
            }
            free(a.arg_buffer);
        }
        if (b.arg_buffer->reference_count > 1) {
            /* We know there are no intros, so just decrement this counter and
               consider b destroyed. */
            b.arg_buffer->reference_count -= 1;
        } else {
            /* We have destroyed some, so destroy the rest and free. */
            for (int i = args_tested; i < b.arg_count; i++) {
                destroy_expr(&b_args[i]);
            }
            free(b.arg_buffer);
        }
    }

    /* We early returned for every other thing that might not match, so now if
       the args match, the whole thing matches. */
    return args_match;
}

bool expr_unify(size_t depth, struct expr *a, struct expr *b) {
    copy_expr(NULL, a);
    copy_expr(NULL, b);

    return expr_unify_destructive(depth, *a, *b);
}

struct check_type_state {
    struct name_buffer names;
    struct expr_buffer var_types;
};

struct expr check_type_rec(struct expr *it, struct check_type_state *state) {
    size_t intro_count = it->lambda_intro_count + it->pi_intro_count;
    struct parameter_spec *specs =
        (struct parameter_spec*)&it->lambda_intro_types[1];
    for (int i = 0; i < intro_count; i++) {
        struct parameter_spec *spec = &specs[i];
        struct expr spec_type_type = check_type_rec(&spec->type, state);
        if (!expr_is_sort(&spec_type_type)) {
            if (spec->name.data) {
                printf("Type error: Parameter %s was annotated with the type ",
                    spec->name.data);
            } else {
                printf("Type error: An arrow expression was given the input "
                    "type ");
            }
            pretty_print_expr_open(&spec->type, &state->names);
            printf(", but this has type ");
            pretty_print_expr_open(&spec_type_type, &state->names);
            printf(", so it is not a valid type annotation.\n");

            /* Only need to destroy it if it isn't a sort. Sorts don't borrow
               anything. */
            destroy_expr(&spec_type_type);
        }

        name_buffer_push(&state->names, spec->name);
        /* Just borrow the type. */
        buffer_push(state->var_types, spec->type);
    }

    size_t ctx_depth = state->var_types.count;

    struct expr curr_type = {0};

    switch (it->head_type) {
        case EXPR_NULL:
        {
            fprintf(stderr, "Error: Cannot infer type of NULL expression.\n");
            exit(EXIT_FAILURE);
            break;
        }
        case EXPR_APPLY_LAMBDA:
        {
            if (it->arg_count == 0) {
                fprintf(stderr, "Error: APPLY LAMBDA with no arguments.\n");
                exit(EXIT_FAILURE);
            }
            struct expr *first_arg = (struct expr*)&it->arg_buffer[1];

            curr_type = check_type_rec(first_arg, state);
            break;
        }
        case EXPR_VAR:
        {
            copy_expr(&curr_type, &state->var_types.data[it->head_var_index]);
            /* If binding types contain nested pi/lambda contexts, then we need
               to rewrite them into this context. */
            deepen_expr_context(
                &curr_type,
                it->head_var_index,
                state->var_types.count
            );
            break;
        }
        case EXPR_GLOBAL:
        {
            fprintf(stderr, "Error: Type inference for global terms is not yet implemented.\n");
            exit(EXIT_FAILURE);
            break;
        }
        case EXPR_SORT:
        {
            curr_type.head_type = EXPR_SORT;
            /* Increase universe level here. */
            break;
        }

        case EXPR_EQUALS:
        {
            /* Equals : (A: Type -> B: Type -> A -> B -> Type) */
            add_pi(&curr_type, "A", universe);
            add_pi(&curr_type, "B", universe);
            add_exp(&curr_type, var(ctx_depth));
            add_exp(&curr_type, var(ctx_depth + 1));
            curr_type.head_type = EXPR_SORT;
            break;
        }
        case EXPR_REFL:
        {
            add_pi(&curr_type, "A", universe);
            add_pi(&curr_type, "x", var(ctx_depth));
            /* Output is a proof of Equal A A x x */
            curr_type.head_type = EXPR_EQUALS;
            apply_body(&curr_type, var(ctx_depth));
            apply_body(&curr_type, var(ctx_depth));
            apply_body(&curr_type, var(ctx_depth + 1));
            apply_body(&curr_type, var(ctx_depth + 1));
            break;
        }
        case EXPR_APPLY_PATH:
        {
            curr_type = apply_path_type(ctx_depth);
            break;
        }
        case EXPR_HETEXT:
        {
            curr_type = het_ext_type(ctx_depth);
            break;
        }
    }

    size_t skip = 0;
    /* Skip the first argument if we already used it to get a type. */
    if (it->head_type == EXPR_APPLY_LAMBDA) skip = 1;

    /* TODO: Embed this skip variable into a loop that incrementally extracts
       pi parameter specs. */
    size_t args_remaining = it->arg_count - skip;

    if (args_remaining > 0) {
        if (args_remaining > curr_type.pi_intro_count) {
            fprintf(stderr, "Error: Tried to apply type that wasn't a pi type. (beta reduction of pi types is not yet implemented.)\n");
            exit(EXIT_FAILURE);
        }
        struct parameter_spec *param_types =
            (struct parameter_spec*)&curr_type.lambda_intro_types[1];

        struct expr *args = (struct expr*)&it->arg_buffer[1];
        for (size_t i = 0; i < args_remaining; i++) {
            struct expr *arg = &args[i + skip];
            struct expr arg_type = check_type_rec(arg, state);
            struct expr expected_type = subst_exprs(
                ctx_depth, &param_types[i].type, false,
                ctx_depth, i, &args[skip]
            );
            /* Unfortunately we can't unify these destructively, as we may need
               the terms themselves for reporting type errors. */
            if (!expr_unify(ctx_depth, &arg_type, &expected_type)) {
                printf("Type checking error: A function expected ");
                pretty_print_expr_open(&expected_type, &state->names);
                printf(", but it was applied to ");
                pretty_print_expr_open(arg, &state->names);
                printf(", which is of type ");
                pretty_print_expr_open(&arg_type, &state->names);
                printf(".\n");
            }
            /* Now manually destroy them. */
            destroy_expr(&expected_type);
            destroy_expr(&arg_type);
        }

        struct expr result_type = subst_exprs(
            ctx_depth, &curr_type, true,
            ctx_depth, args_remaining, &args[skip]
        );
        destroy_expr(&curr_type);
        curr_type = result_type;
    }

    if (it->pi_intro_count > 0) {
        if (!expr_is_sort(&curr_type)) {
            /* Borrow `it` but hide the lambda/pi part. */
            struct expr it_copy = *it;
            it_copy.lambda_intro_count = 0;
            it_copy.pi_intro_count = 0;

            printf("Type error: Arrow expression was applied to ");
            pretty_print_expr_open(&it_copy, &state->names);
            printf(", which is not a type.\n");
        }
    }

    if (it->lambda_intro_count > 0) {
        size_t prev_param_count = curr_type.pi_intro_count;
        parameter_spec_buffer_addn(
            &curr_type.lambda_intro_types,
            it->lambda_intro_count
        );
        struct parameter_spec *curr_specs =
            (struct parameter_spec *)&curr_type.lambda_intro_types[1];
        /* Move curr[0..prev_count] to curr[it.count..new_count] */
        memmove(
            &curr_specs[it->lambda_intro_count],
            curr_specs,
            prev_param_count * sizeof(struct parameter_spec)
        );
        /* Copy it[0..it.count] to curr[0..it.count] */
        struct parameter_spec *it_specs =
            (struct parameter_spec *)&it->lambda_intro_types[1];
        for (int i = 0; i < it->lambda_intro_count; i++) {
            curr_specs[i].name = it_specs[i].name;
            copy_expr(&curr_specs[i].type, &it_specs[i].type);
        }
        curr_type.pi_intro_count += it->lambda_intro_count;
    }

    for (int i = 0; i < intro_count; i++) {
        buffer_pop(state->names);
        buffer_pop(state->var_types);
    }

    return curr_type;
}

struct expr check_type(struct expr *it) {
    struct check_type_state state = {0};
    struct expr result = check_type_rec(it, &state);
    buffer_free(state.names);
    buffer_free(state.var_types);
    return result;
}

#endif
